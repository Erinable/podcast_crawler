#!/bin/bash

# 检查参数
if [ "$#" -ne 2 ]; then
    echo "Usage: $0 <module_path> <module_name>"
    echo "Example: $0 src/api handlers/podcast"
    exit 1
fi

MODULE_PATH=$1
MODULE_NAME=$2
FULL_PATH="$MODULE_PATH/$MODULE_NAME"

# 创建目录
mkdir -p "$FULL_PATH"

# 创建 mod.rs
cat > "$FULL_PATH/mod.rs" << EOL
//! $MODULE_NAME module
//!
//! This module was automatically generated by generate_module.sh

use crate::infrastructure::error::AppResult;

pub mod models;
pub mod handlers;
pub mod service;

pub use self::models::*;
pub use self::handlers::*;
pub use self::service::*;
EOL

# 创建 models.rs
cat > "$FULL_PATH/models.rs" << EOL
//! Data models for $MODULE_NAME

use serde::{Deserialize, Serialize};
use uuid::Uuid;
use chrono::{DateTime, Utc};

#[derive(Debug, Serialize, Deserialize)]
pub struct ${MODULE_NAME^}CreateDto {
    // TODO: Add fields
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ${MODULE_NAME^}UpdateDto {
    // TODO: Add fields
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ${MODULE_NAME^}ResponseDto {
    pub id: Uuid,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
    // TODO: Add fields
}
EOL

# 创建 handlers.rs
cat > "$FULL_PATH/handlers.rs" << EOL
//! Request handlers for $MODULE_NAME

use actix_web::{web, HttpResponse};
use uuid::Uuid;
use crate::infrastructure::error::AppResult;
use super::{models::*, service::*};

pub async fn create(
    payload: web::Json<${MODULE_NAME^}CreateDto>,
    service: web::Data<${MODULE_NAME^}Service>,
) -> AppResult<HttpResponse> {
    let result = service.create(payload.into_inner()).await?;
    Ok(HttpResponse::Created().json(result))
}

pub async fn get(
    id: web::Path<Uuid>,
    service: web::Data<${MODULE_NAME^}Service>,
) -> AppResult<HttpResponse> {
    let result = service.get(id.into_inner()).await?;
    Ok(HttpResponse::Ok().json(result))
}

pub async fn update(
    id: web::Path<Uuid>,
    payload: web::Json<${MODULE_NAME^}UpdateDto>,
    service: web::Data<${MODULE_NAME^}Service>,
) -> AppResult<HttpResponse> {
    let result = service.update(id.into_inner(), payload.into_inner()).await?;
    Ok(HttpResponse::Ok().json(result))
}

pub async fn delete(
    id: web::Path<Uuid>,
    service: web::Data<${MODULE_NAME^}Service>,
) -> AppResult<HttpResponse> {
    service.delete(id.into_inner()).await?;
    Ok(HttpResponse::NoContent().finish())
}

pub async fn list(
    service: web::Data<${MODULE_NAME^}Service>,
) -> AppResult<HttpResponse> {
    let result = service.list().await?;
    Ok(HttpResponse::Ok().json(result))
}

#[cfg(test)]
mod tests {
    use super::*;
    use actix_web::test;

    // TODO: Add tests
}
EOL

# 创建 service.rs
cat > "$FULL_PATH/service.rs" << EOL
//! Service layer for $MODULE_NAME

use uuid::Uuid;
use crate::infrastructure::error::AppResult;
use super::models::*;

#[derive(Debug)]
pub struct ${MODULE_NAME^}Service {
    // TODO: Add dependencies
}

impl ${MODULE_NAME^}Service {
    pub fn new() -> Self {
        Self {
            // TODO: Initialize dependencies
        }
    }

    pub async fn create(&self, dto: ${MODULE_NAME^}CreateDto) -> AppResult<${MODULE_NAME^}ResponseDto> {
        // TODO: Implement create
        unimplemented!()
    }

    pub async fn get(&self, id: Uuid) -> AppResult<${MODULE_NAME^}ResponseDto> {
        // TODO: Implement get
        unimplemented!()
    }

    pub async fn update(&self, id: Uuid, dto: ${MODULE_NAME^}UpdateDto) -> AppResult<${MODULE_NAME^}ResponseDto> {
        // TODO: Implement update
        unimplemented!()
    }

    pub async fn delete(&self, id: Uuid) -> AppResult<()> {
        // TODO: Implement delete
        unimplemented!()
    }

    pub async fn list(&self) -> AppResult<Vec<${MODULE_NAME^}ResponseDto>> {
        // TODO: Implement list
        unimplemented!()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    // TODO: Add tests
}
EOL

# 设置文件权限
chmod 644 "$FULL_PATH"/*.rs

echo "Generated module at $FULL_PATH"
echo "Don't forget to:"
echo "1. Add the module to the parent mod.rs"
echo "2. Configure routes in your router"
echo "3. Add necessary dependencies to Cargo.toml"
